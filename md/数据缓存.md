## 数据缓存

[TOC]

### 1、前言

在实际项目中，我们不仅需要实现应用的功能，也需要考虑整个应用的性能问题。当大量用户访问相同数据时，对数据库是个很大的考验。这时候如果使用数据缓存技术了，同样的数据就不需要通过访问数据库获取处理，在应用层面就可以拿到缓存数据，可以减轻数据库的压力、同时也能提高数据的响应速度。

> 那么在Spring Boot中提供哪些缓存支持呢？

`Spring Framework`中提供了对缓存数据的支持，核心是通过在方法中应用缓存方法，然后根据缓存中的已有可用信息来减少大量的执行次数。`Spring Boot`自动携带了缓存的基础配置，我们只需要使用注解`@EnableCaching`即可开启缓存功能。

举例说明;

~~~java
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MathService {

	@Cacheable("piDecimals")
	public int computePiDecimal(int i) {
		// ...
	}

}
~~~

上述的举例是，缓存一个需要复杂计算的计算方法，那么具体是怎么执行的呢？

在`computePiDecimal`方法执行之前，会查找`piDecimals`的缓存，并从中取匹配`i`这个参数，如果数据存在，立刻把数据返回给调用者，然后这个方法`computePiDecimal`并不会执行。否则执行方法，在返回数据给调用者之前就更新数据到缓存中。

如果没有添加指定的缓存库，`Spring Boot`自动配置了一个简单的`Simple Provider`，通过`concurrent maps`保存缓存数据。比如上面的`piDecimals`缓存，当缓存存在时，调用方法时，会通过`simple provider` 直接返回。`simple provider` 不建议应用于正式生产环境，如果只是测试熟悉缓存技术还是不错的。

### 2、**CacheManager**缓存分类

`Spring` 定义 `CacheManager` 和 `Cache` 接口用来统一不同的缓存技术。例如 `JCache、 EhCache、 Hazelcast、 Guava、 Redis` 等。在使用 `Spring` 集成 `Cache` 的时候，我们需要注册实现的 `CacheManager` 的 `Bean。Spring Boot 默认使用的是 SimpleCacheConfiguration，即使用 ConcurrentMapCacheManager 来实现的缓存。`

`CacheManager`是专门用来缓存管理器，管理各种缓存组件的；

针对不同的缓存技术，实现了不同的 `CacheManager` ，`Spring` 定义了下表所示的 `CacheManager`：

| CacheManager              | 描述                                                         |
| ------------------------- | :----------------------------------------------------------- |
| SimpleCacheManager        | 使用简单的 Collection 来存储缓存，主要用于测试               |
| ConcurrentMapCacheManager | 使用 ConcurrentMap 来存储缓存                                |
| NoOpCacheManager          | 仅测试用途，不会实际缓存数据                                 |
| EhCacheCacheManager       | 使用 EhCache 作为缓存技术                                    |
| GuavaCacheManager         | 使用 Google Guava 的 GuavaCache 作为缓存技术                 |
| HazelcastCacheManager     | 使用 Hazelcast 作为缓存技术                                  |
| JCacheCacheManager        | 支持 JCache(JSR-107) 标准的实现作为缓存技术，如 ApacheCommonsJCS |
| RedisCacheManager         | 使用 Redis 作为缓存技术                                      |

缓存接口有以下分类：

1. [Generic](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-generic)
2. [JCache (JSR-107)](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-jcache) (EhCache 3, Hazelcast, Infinispan, and others)
3. [EhCache 2.x](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-ehcache2)
4. [Hazelcast](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-hazelcast)
5. [Infinispan](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-infinispan)
6. [Couchbase](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-couchbase)
7. [Redis](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-redis)
8. [Caffeine](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-caffeine)
9. [Simple](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-simple)

详细列举，请进入[Spring Boot Cache](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/boot-features-caching.html#boot-features-caching-provider-infinispan)

我们在这里将只讲解`Simple`和`Redis`，`Simple`用于测试，`Redis`用于实际用途。其他的平时不多用，可以自行了解。

### 3、具体实现

#### 3.1、自定义是否开启缓存

`是否开启缓存，有两种方法:`

> 方法一：

在不同环境的配置文件中如application-dev.yml、application-test.yml、application-prod.yml，修改 spring.cache.type = none;

~~~yml
spring:
  cache:
  	type: none	
~~~

> 方法二：
>
> 自定义配置

> application.yml

~~~yml
## 开启数据缓存
caching:
  enabled: true

~~~

> com.scaffold.test.config.CacheConfig
>
> 缓存配置文件

~~~java
@Configuration
@EnableCaching
//配置文件读取是否启用此配置
@ConditionalOnProperty(prefix = "caching", name = "enabled", havingValue = "true")
public class CacheConfig {

}
~~~

#### 3.2、simpleCacheManage

##### 3.2.1、概要介绍

`simpleCacheManage` 基于`ConcurrentHashMap` 实现，不依赖其他库，如果增加了注解`@EnableCaching`，默认开启缓存，可以通过设置`cache-names`限制缓存列表

> 设置缓存列表

> application.yml

~~~yaml
spring:
  cache:
  	type: simple
  	cache-names: cache1,cache2
~~~

> 或者
>
> 增加配置文件 cacheConfig

~~~java
@Configuration
public class CacheConfig {
   @Bean
   public CacheManager cacheManager() {
       return new ConcurrentMapCacheManager("cache1", "cache2");
   }
}
~~~

> maven依赖

~~~xml
<!-- cache 依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
~~~

==注意：所有的注解是加到实现类方法上的==

| 注解        | 描述                                                         |
| ----------- | :----------------------------------------------------------- |
| @Cacheable  | 在方法执行前 Spring 先查看缓存中是否有数据，若有，则直接返回缓存数据；若无数据，调用方法将方法返回值放入缓存中 |
| @CachePut   | 无论怎样，都会将方法的返回值放到缓存中。                     |
| @CacheEvict | 将一条或多条数据从缓存中删除                                 |
| @Caching    | 可以通过 @Caching 注解组合多个注解策略在一个方法             |

`@Cacheable、@CachePut、@CacheEvict 都有 value 属性`，指定的是要使用的缓存名称；`key 属性指定的是数据在缓存中存储的键`。

##### 3.2.2、代码实现

> 配置类

~~~java
package com.scaffold.test.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

/**
 * 缓存配置文件
 * 配置文件读取是否启用此配置
 * @author alex
 */
@Configuration
@EnableCaching
@ConditionalOnProperty(prefix = "caching", name = "enabled", havingValue = "true")
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("cacheData");
    }
  }
~~~

> 实体类
>
> com.scaffold.test.entity.Student

~~~java
package com.scaffold.test.entity;

import lombok.Data;
import lombok.EqualsAndHashCode;

import java.io.Serializable;

/**
 * @author alex wong
 */
@Data
@EqualsAndHashCode(callSuper = false)
public class Student implements Serializable {

    private static final long serialVersionUID=1L;

    @TableId(value = "id", type = IdType.AUTO)
    private int id;

    private String name;

    private Integer age;

}

~~~

> service层
>
> com.scaffold.test.service.StudentService

~~~java
package com.scaffold.test.service;

import com.scaffold.test.entity.Student;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author alex wong
 */
public interface StudentService extends IService<Student> {

    List<Student> findAll();

    Student findStudent(Student student);

    Student testStudent(String text);

}

~~~

> service实现类
>
> com.scaffold.test.service.StudentService

~~~java
package com.scaffold.test.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.scaffold.test.entity.Student;
import com.scaffold.test.mapper.StudentMapper;
import com.scaffold.test.service.StudentService;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author alex wong
 */
@Service
public class StudentServiceImpl extends ServiceImpl<StudentMapper, Student> implements StudentService {

    @Resource
    private StudentMapper studentMapper;

    @Override
    @Cacheable(value = "cacheData")
    public List<Student> findAll(){
        return studentMapper.selectAll();
    }

    @Override
    @Cacheable(value = "cacheData")
    public Student findStudent(Student student) {
        int id = student.getId();
        if(id == 0){
            return null;
        }
        return studentMapper.findStudent(student);
    }

    @Override
    @Cacheable(value = "cacheData", key = "#text")
    public Student testStudent(String text) {
        System.out.println("test" + text);
        Student student = new Student();
        student.setName(text);
        return student;
    }
}

~~~

> dao层（data access object数据访问层）
>
> com.scaffold.test.mapper.StudentMapper

~~~java
package com.scaffold.test.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.scaffold.test.entity.Student;

import java.util.List;

/**
 * <p>
 * Mapper 接口
 * </p>
 *
 * @author alex wong
 */
public interface StudentMapper extends BaseMapper<Student> {

    List<Student> selectAll();

    Student findStudent(Student student);
}

~~~

> src/main/resources/mapper/StudentMapper.xml

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.scaffold.test.mapper.StudentMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.scaffold.test.entity.Student">
        <result column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="age" property="age"/>
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id,
        name, age
    </sql>

    <sql id="Where_Condition">
        <where>
            <if test="id != null and id != ''">
                id=#{id}
            </if>
            <if test="name != null and name != ''">
                and name=#{name}
            </if>
            <if test="age != null and age != ''">
                and age=#{age}
            </if>
        </where>
    </sql>
    
    <select id="selectAll" resultMap="BaseResultMap">
        select * from student
    </select>
    <select id="findStudent" resultType="com.scaffold.test.entity.Student">
        select * from student
        <include refid="Where_Condition"></include>
    </select>
</mapper>
~~~

> sql

~~~sql

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for student
-- ----------------------------
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `age` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of student
-- ----------------------------
INSERT INTO `student` VALUES (1, '1', 2323);
INSERT INTO `student` VALUES (2, '2', 2323);
INSERT INTO `student` VALUES (3, '3', 2323);

SET FOREIGN_KEY_CHECKS = 1;
~~~

> Controller层
>
> com.scaffold.test.controller.StudentController

~~~java
package com.scaffold.test.controller;


import com.scaffold.test.entity.Student;
import com.scaffold.test.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 *
 * @author alex wong
 */
@RestController
@RequestMapping("/student")
public class StudentController {

    @Autowired
    private StudentService studentService;

    @GetMapping("list")
    public List<Student> getAll(){
        return studentService.findAll();
    }

    @GetMapping("find")
    public Student findStudent(Student student){
        return studentService.findStudent(student);
    }

    @GetMapping("test")
    public Student test(@RequestParam String text){
        return studentService.testStudent(text);
    }
}
~~~

> 接下来测试一下缓存@Cacheable

![1601198899017](%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.assets/1601198899017.png)

第一次执行日志：

![1601198920569](%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.assets/1601198920569.png)

第二次执行日志：

![1601198944733](%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.assets/1601198944733.png)

日志没有增加，说明没有查询数据库；

我们添加Debuger，测试下方法有没有执行？

![1601198982390](%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.assets/1601198982390.png)

结果`findStudent`方法并没有执行，`说明数据全部取自缓存`。





